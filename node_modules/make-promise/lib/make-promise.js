// Generated by CoffeeScript 1.6.2
(function() {
  var makePromise, resolve;

  require("setimmediate");

  module.exports = makePromise = function(fn) {
    var call, deferreds, error, finalState, handle, resolved, resultCB, state;

    state = void 0;
    finalState = void 0;
    deferreds = [];
    resolved = function(fn) {
      if (state === void 0) {
        return fn(void 0);
      }
      if (finalState != null) {
        return fn(finalState);
      }
      return resolve(state, function(resolvedState) {
        return fn(finalState = resolvedState);
      });
    };
    handle = function(deferred, state) {
      if (state == null) {
        return deferreds.push(deferred);
      } else {
        return setImmediate(function() {
          return call(deferred, state);
        });
      }
    };
    call = function(deferred, _arg) {
      var cb, err, kept, value;

      kept = _arg[0], value = _arg[1];
      cb = kept ? deferred.whenKept : deferred.whenBroken;
      if (typeof cb === "function") {
        try {
          return deferred.cb(null, cb(value));
        } catch (_error) {
          err = _error;
          return deferred.cb(err, null, true);
        }
      }
      if (kept) {
        return deferred.cb(null, value);
      } else {
        return deferred.cb(value, null, true);
      }
    };
    resultCB = function(err, result, forceError) {
      if (forceError == null) {
        forceError = false;
      }
      if (state !== void 0) {
        return;
      }
      state = err || forceError ? [false, err] : [true, result];
      return resolved(function(state) {
        var deferred, _results;

        _results = [];
        while (deferred = deferreds.shift()) {
          _results.push(call(deferred, state));
        }
        return _results;
      });
    };
    try {
      fn(resultCB);
    } catch (_error) {
      error = _error;
      resultCB(error, null, true);
    }
    return {
      then: function(whenKept, whenBroken) {
        if ((whenKept != null) && typeof whenKept === "object" && (whenKept.onFulfilled || whenKept.onRejected)) {
          whenBroken = whenKept.onRejected;
          whenKept = whenKept.onFulfilled;
        }
        return makePromise(function(cb) {
          return resolved(function(state) {
            return handle({
              whenKept: whenKept,
              whenBroken: whenBroken,
              cb: cb
            }, state);
          });
        });
      }
    };
  };

  resolve = function(_arg, cb) {
    var kept, value;

    kept = _arg[0], value = _arg[1];
    if (!kept) {
      return cb([false, value]);
    }
    if (!value || typeof value.then !== "function") {
      return cb([true, value]);
    }
    return value.then((function(value) {
      return resolve([true, value], cb);
    }), function(err) {
      return cb([false, err]);
    });
  };

}).call(this);

/*
//@ sourceMappingURL=make-promise.map
*/
